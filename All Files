//Ok so here is what I have so far. I'm sorry it took me so long to post. I got caught up trying to fix my runtime errors. 
//They're still not fixed. I'm having trouble with linking the pointer in the struct in each vector indext to the movie
//it matches to. 

//////////////////////////////////////////////////HEADER////////////////////////////////////////////////////////////////
#ifndef IMDB_H
#define IMDB_H

#include <vector>
#include <string>
#include <iostream>
#include <fstream>
#include <time.h>
#include <sstream>
#include <algorithm>

class data
{
private:
	struct element
	{
		std::string Name;	// The name of the element (Title, Rating, Director, Actor)
		typedef element* MoviePtr;		// A pointer to the movie that this was in
		MoviePtr link;
		element(std::string theName)
		{
			Name = theName;
			link = nullptr;
		}

	};
	 //there's error for the 'theName'
	typedef element* indexPtr;
	typedef std::vector<element> kindList; // The vector of each category list
	kindList Movie, Rating, Director, Actor, theMovies;
	int m,r,d,a, M;
	enum category
	{
		T = 1, //title
		R, //rating
		D, //director
		S //actors
	};
	int comma, //keeps track of placement in string for parseCommas fnt
		space; //keeps track of placement in string for parseSpaces fnt

public:
	data();		// Class constructor
	~data();	// Class destructor

	void Display();
	int SORT(std::vector<element> obj, std::string rawData);
	//friend bool operator< (vector<element>& lhs, vector<element>& rhs);
	std::string readFile(std::istream& FILE);
	std::string parseCommas(std::string rawData);
	std::string parseSpaces(std::string rawData);
	std::string parseActors(std::string rawData);
	std::string stringToupper(std::string rawData);
	bool addNew(std::string rawData); // IF parseCommas is run outside of this, then the param can be empty
	indexPtr binarySearch(kindList list, std::string search_term);
	bool getMatch(category group, std::string sub_string);
	void printMatch(element::MoviePtr titleName);

};

class stopWatch // Time object
{
private:
	time_t startTime;
	time_t stopTime;

public:
	stopWatch();			// Class Constructor
	~stopWatch();		// Class destructor
	
	void timeGo();		// Start the clock
	void timeStop();		// Start the clock
	double duration();	// Return the total duration

};

#endif // IMDB_H
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////IMPLEMENTATION////////////////////////////////////////////////////////
#include "Lab06.h"
using namespace std;

//class data
// Class constructor
	data::data()
	{
		comma = 0;
		space = 0;
		m=0;
		d=0;
		r=0;
		a=0;
		M=0;

	}
	

	// Class destructor
	data::~data()
	{

	}

	string data::readFile(istream& FILE)
	{
		string item;
		while(!FILE.eof())
		{
			comma = 0;
			space = 0;
			getline(FILE, item);
			addNew(item);
		}
		//SORT();
		// Takes in the initialization file as input.
		// Returns the length of the raw data string from the file, or zero on failure
		return item;
	}

	string data::parseCommas(string rawData)
	{
		if(rawData.at(comma) == rawData.size())
		{
			comma = 0;
			return "0";
		}
		else if(rawData.at(comma) == ' ')
			comma += 1;
		string temp, TEMP;
		int i=0, diff= rawData.size() - comma;
		while(rawData.at(comma) != ',' && i < diff)
		{
			TEMP = rawData.at(comma);
			temp.append(TEMP);
			comma++;
		}
		comma++;
		return temp;
		/*if(rawData.at(comma) == '\0')
			return "0";
		else 
			return temp;
		/*
		if(rawData.at(amount) == ' ')
			rawData.erase(pos,amount+1);
		else 
			rawData.erase(pos,amount);*/
		// Read raw data string up to first comma
		// Return string with leading/trailing whitespace stripped
		// Repeat until string.end()
	}
	
	string data::parseSpaces(string rawData)
	{
		if(space == rawData.size())
		{
			space = 0;
			return "0"; //or we can say while string.at(string.length()) != comma in addnew function
		}
		else if(rawData.at(space) == ' ')
			space += 1;
		else if(rawData.at(space) == ',')
			space += 2;
		string temp, TEMP;
		int i=0, diff = rawData.size() - space;
		while(i < diff && rawData.at(space) != ' ' && rawData.at(space) != ',')
		{
			TEMP = rawData.at(space);
			temp.append(TEMP);
			space++;
			i++;
		}
		//rawData.erase(pos,i);
		return temp;
	}

	string data::parseActors(string rawData)
	{
		string temp, TEMP;
		//make a check
		if(rawData.at(comma) == ' ')
			comma += 1;
		else if(rawData.at(comma) == (rawData.size() - 1))
		{
			comma = 0;
			return "0";
		}
		int i=0, diff= rawData.size() - comma;
		while(i < diff)
		{
			TEMP = rawData.at(comma);
			temp.append(TEMP);
			comma++;
			i++;
		}
		return temp;
	}

	string data::stringToupper(string rawData)
	{
		int i=0;
		while(i < rawData.size())
		{
			rawData.at(i) = toupper(rawData.at(i));
			i++;
		}
		return rawData;
	}


	bool data::addNew(string rawData) // IF parseCommas is run outside of this, then the param can be empty
	{
		string movie, rating, director, actors, bySpace;
		int compare = 0;
		vector<element>:: iterator it;
		movie = parseCommas(rawData);
		theMovies.push_back(element(movie));
		
		rating = parseCommas(rawData);
		director = parseCommas(rawData);
		actors = parseActors(rawData);

		bySpace = parseSpaces(movie);
		while(bySpace != "0")
		{
			//toupper byspace
			bySpace = stringToupper(bySpace);
			compare = SORT(Movie, bySpace);
			if(compare == 0)
				Movie.push_back(element(bySpace));
			else 
			{
				//***in progress***//
				it = &Movie[compare];
				Movie[compare].insert(element(bySpace));
			}
			Movie[m].link = theMovies[M].link;
			m++;
			bySpace = parseSpaces(movie);
			//build movie vector
			//set pointers
		}	

		bySpace = parseSpaces(director);
		while(bySpace != "0")
		{
			//toupper byspace
			bySpace = stringToupper(bySpace);
			Director.push_back(element(bySpace));
			Director[d].link = theMovies[M].link;
			d++;
			bySpace = parseSpaces(director);
			//build director vector
			//set pointers
		}
		
		bySpace = parseSpaces(actors);
		while(bySpace != "0")
		{
			//toupper byspace
			bySpace = stringToupper(bySpace);
			Actor.push_back(element(bySpace));
			Actor[a].link = theMovies[M].link;
			a++;
			bySpace = parseSpaces(actors);
			//build actors vector
			//set pointers
		}

		bySpace = parseSpaces(rating);
		Rating.push_back(element(bySpace));
		Rating[r].link = theMovies[M].link;
		r++;
		M++;
		
		
		//build rating vector
		//set pointers

		// Iteratively read strips from the rawData
		/* For each category/strip read :
		 * 1) Search for spot in kindList for data element
		 * 2) Assign a kindList.element block for that strip
		 * 3) Link element.MoviePtr -> Movie
		 */
		// Return 0 if fail; 1 if success
		return true;
	}

	int data::SORT(vector<element> obj, string rawData)
	{ 
		int i=0;
		while( i < obj.size())
		{
			if(obj[i].Name.compare(rawData) == 0)
				return i;
			else if(obj[i].Name.compare(rawData) == -1)
				i++;
			else if(obj[i].Name.compare(rawData) == 1)
				return i-1;
			else 
				return 0;
		}
		return 0;
	}

	void data::Display()
	{
		//vector<element>::iterator it;
		int i=0;
		//for(it = Movie.begin(); it != Movie.end(); it++)
		for(i=0;i<Movie.size();i++)
			cout << Movie[i].Name << endl;
		cout << endl;
		i=0;
		for(i=0;i<Rating.size();i++)
			cout << Rating[i].Name << endl;
		cout << endl;
		i=0;
		for(i=0;i<Director.size();i++)
			cout << Director[i].Name << endl;
		cout << endl;
		i=0;
		for(i=0;i<Actor.size();i++)
			cout << Actor[i].Name << endl;
		cout << endl;
	}

	data::indexPtr data::binarySearch(kindList list, string search_term)
	{
		int i;
		int bottom = 0, top = 0, middle = 0, found = 0;
		top = list.size();
		search_term = stringToupper(search_term);
		while(bottom < top && found == 0)
		{
			middle = (top + bottom)/2;
			if( search_term == list[middle].Name)
			{
				found = 1;
				i = middle;
			}
			else if(list[middle].Name > search_term)
				top = middle-1;
			else
				bottom = middle + 1;
		}

		if(found == 1)
			return list[i].link;
		else
			return nullptr;
		// This could be potentially be replaced by std::binary_search from the algorithm library
		// .. though, i don't know how easily we can adapt that to our needs
		// Use std::string.compare() to determine break direction.
		// Use kindList.size() for START and END markers
		// Return an indexPtr to the first matching element or nullptr if not found
		return 0;
	}

	bool data::getMatch(category group, string sub_string)
	{
		// Use binarySearch to find first match
		// Use linear search up, and then down the block to find all possible adjacent matches
		// printMatch() for each match found
		return 0;
	}

	void data::printMatch(element::MoviePtr titleName)
	{
		// Possibly print some header info
		// Print out titleName->Name()
	}


//class stopWatch // Time object

	stopWatch::stopWatch()			// Class Constructor
	{
		startTime = 0;
		stopTime = 0;
	}
	stopWatch::~stopWatch()		// Class destructor
	{
		delete &startTime;
		delete &stopTime;
	}

	void stopWatch::timeGo()		// Start the clock
	{
		startTime = time(NULL);
	}
	void stopWatch::timeStop()		// Start the clock
	{
		stopTime = time(NULL);
	}
	double stopWatch::duration()	// Return the total duration
	{
		// This probably needs to be formatted..
		return difftime(startTime,stopTime);
	}



	/*
		//sorting Movie
		int k = Movie.size();
		string *first = &Movie[0].Name;
		string *last = &Movie[Movie.size()-1].Name;
		sort(first, last);
		//sorting director
		k = Director.size();
		first = &Director[0].Name;
		last = &Director[Director.size()-1].Name;
		sort(first, last);
		//sorting actor
		k = Actor.size();
		first = &Actor[0].Name;
		last = &Actor[Actor.size()-1].Name;
		sort(first, last);
		//sorting rating
		k = Rating.size();
		first = &Rating[0].Name;
		last = &Rating[Rating.size()-1].Name;
		sort(first, last);
		*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////DRIVER///////////////////////////////////////////////////////////////
#include "Lab06.h"
using namespace std;

int main()
{
	data Hello;
	ifstream file("imdbTest.txt");
	Hello.readFile(file);
	//Hello.Display();
	srand(time(0));

	string str1 = "ABCD", str2 = "EFGH";
	cout << "str1: " << str1 << endl << "str2: " << str2 << endl;
	cout << "str1.compare(str2): " << str1.compare(str2) << endl;
	cout << "str2.compare(str1): " << str2.compare(str1) << endl;

	/*
		string item, line1;
		ifstream infile("imdbTest.txt");
		getline(infile, item, ',');
		//one problem it reads in the space
		getline(infile, line1, ',');
		line1.erase(0,1); //we'll have to ask if there will always be a space after each comma
		
		int* hi;
		hi = nullptr;

		cout << item << endl << line1 << endl;

		string* strArray;
		string str = "This is the day", temp;

		int i=0;
		/*
		while(i<str.length())
		{
			//grrr
		}

		*/
	return 0;
}


//Will there always be a space after each comma?
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


